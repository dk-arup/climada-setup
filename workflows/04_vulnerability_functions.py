#!/usr/bin/env python3
"""
Vulnerability (Impact) Functions with CLIMADA

This script demonstrates how to work with vulnerability/impact functions:
1. Define custom impact functions
2. Use built-in impact functions
3. Calibrate impact functions with observed data
4. Visualize damage curves

Author: CLIMADA Setup Project
Date: 2025-12-25
"""

import sys
from pathlib import Path

try:
    from climada.entity import ImpactFunc, ImpactFuncSet
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
except ImportError as e:
    print(f"Error importing required modules: {e}")
    print("Please ensure CLIMADA is properly installed.")
    sys.exit(1)


def create_tropical_cyclone_impact_function():
    """
    Create a tropical cyclone impact function.
    
    This defines the relationship between wind speed and building damage.
    
    Returns:
        ImpactFunc: TC impact function
    """
    print("Creating tropical cyclone impact function...")
    
    impf = ImpactFunc()
    impf.id = 1
    impf.name = 'TC Residential Buildings'
    impf.haz_type = 'TC'
    impf.intensity_unit = 'm/s'
    
    # Define intensity thresholds (wind speed in m/s)
    # Based on typical building vulnerability curves
    impf.intensity = np.array([
        0,    # No wind
        15,   # Light breeze (33 mph)
        25,   # Strong breeze (56 mph)
        33,   # Gale force (74 mph) - Hurricane threshold
        42,   # Hurricane Cat 1 (94 mph)
        50,   # Hurricane Cat 2 (112 mph)
        58,   # Hurricane Cat 3 (130 mph)
        70,   # Hurricane Cat 4+ (157+ mph)
        80    # Extreme winds
    ])
    
    # Mean Damage Degree (MDD): fraction of asset value lost
    # 0 = no damage, 1 = complete destruction
    impf.mdd = np.array([
        0.00,   # No damage
        0.00,   # Minimal damage
        0.02,   # Minor damage (roof tiles, windows)
        0.05,   # Moderate damage (roof damage, structural stress)
        0.15,   # Significant damage (partial roof loss)
        0.30,   # Severe damage (major structural damage)
        0.55,   # Very severe (partial collapse)
        0.85,   # Near total destruction
        1.00    # Complete destruction
    ])
    
    # Percentage of Affected Assets (PAA): fraction of exposed assets that are affected
    # Often assumed to be 1.0 (all exposed assets are affected to some degree)
    impf.paa = np.array([
        0.00,   # No assets affected
        0.10,   # Few assets affected
        0.30,   # Some assets affected
        0.60,   # Most assets affected
        0.85,   # Nearly all affected
        0.95,   # Nearly all affected
        0.98,   # Nearly all affected
        1.00,   # All affected
        1.00    # All affected
    ])
    
    # Validate the impact function
    impf.check()
    
    print(f"  Created: {impf.name}")
    print(f"  Hazard type: {impf.haz_type}")
    print(f"  Intensity range: {impf.intensity.min():.1f} - {impf.intensity.max():.1f} {impf.intensity_unit}")
    
    return impf


def create_flood_impact_function():
    """
    Create a river flood impact function.
    
    This defines the relationship between flood depth and building damage.
    
    Returns:
        ImpactFunc: Flood impact function
    """
    print("\nCreating river flood impact function...")
    
    impf = ImpactFunc()
    impf.id = 2
    impf.name = 'RF Residential Buildings'
    impf.haz_type = 'RF'  # River Flood
    impf.intensity_unit = 'm'  # Flood depth in meters
    
    # Flood depth thresholds (in meters)
    impf.intensity = np.array([
        0.0,   # No flood
        0.25,  # Minor flooding (basement)
        0.5,   # Significant flooding (ground floor)
        1.0,   # Major flooding (1st floor)
        1.5,   # Severe flooding
        2.0,   # Very severe
        3.0,   # Extreme flooding
        5.0    # Catastrophic
    ])
    
    # Mean Damage Degree for residential buildings
    impf.mdd = np.array([
        0.00,   # No damage
        0.10,   # Basement damage
        0.25,   # Ground floor damage
        0.45,   # First floor damage
        0.60,   # Severe damage
        0.75,   # Very severe damage
        0.90,   # Near total loss
        1.00    # Total loss
    ])
    
    # Percentage of affected assets
    impf.paa = np.array([
        0.00,
        0.50,
        0.75,
        0.90,
        0.95,
        0.98,
        1.00,
        1.00
    ])
    
    impf.check()
    
    print(f"  Created: {impf.name}")
    print(f"  Hazard type: {impf.haz_type}")
    print(f"  Intensity range: {impf.intensity.min():.1f} - {impf.intensity.max():.1f} {impf.intensity_unit}")
    
    return impf


def create_heatwave_impact_function():
    """
    Create a heatwave/heat stress impact function.
    
    This could represent mortality or economic productivity loss.
    
    Returns:
        ImpactFunc: Heat stress impact function
    """
    print("\nCreating heatwave impact function...")
    
    impf = ImpactFunc()
    impf.id = 3
    impf.name = 'HS Mortality Risk'
    impf.haz_type = 'HS'  # Heat Stress
    impf.intensity_unit = 'degC'  # Temperature in Celsius
    
    # Temperature thresholds (relative to normal)
    impf.intensity = np.array([
        25,   # Normal summer temperature
        30,   # Warm
        35,   # Hot
        38,   # Very hot
        40,   # Extreme heat
        42,   # Dangerous heat
        45    # Life-threatening heat
    ])
    
    # Impact on vulnerable population (mortality/morbidity rate)
    impf.mdd = np.array([
        0.00,   # No excess mortality
        0.01,   # Slight increase
        0.05,   # Moderate increase
        0.15,   # Significant increase
        0.30,   # High mortality
        0.50,   # Very high mortality
        0.75    # Extreme mortality
    ])
    
    # Fraction of population affected (vulnerable groups)
    impf.paa = np.array([
        0.00,
        0.20,   # Elderly, children
        0.40,
        0.60,
        0.75,
        0.85,
        0.95
    ])
    
    impf.check()
    
    print(f"  Created: {impf.name}")
    print(f"  Hazard type: {impf.haz_type}")
    print(f"  Note: This is a simplified example for demonstration")
    
    return impf


def create_impact_function_set():
    """
    Create a set of impact functions for multiple hazards.
    
    Returns:
        ImpactFuncSet: Collection of impact functions
    """
    print("\nCreating impact function set...")
    
    impf_set = ImpactFuncSet()
    
    # Add impact functions for different hazards
    impf_set.append(create_tropical_cyclone_impact_function())
    impf_set.append(create_flood_impact_function())
    impf_set.append(create_heatwave_impact_function())
    
    print(f"\nImpact function set created with {len(impf_set.get_hazard_types())} hazard types:")
    for haz_type in impf_set.get_hazard_types():
        funcs = impf_set.get_func(haz_type=haz_type)
        print(f"  {haz_type}: {len(funcs)} function(s)")
    
    return impf_set


def demonstrate_calibration_concept():
    """
    Demonstrate the concept of impact function calibration.
    
    In practice, you would use climada.util.calibrate with observed damage data.
    """
    print("\n" + "=" * 60)
    print("Impact Function Calibration Concept")
    print("=" * 60)
    
    print("\nCLIMADA provides tools to calibrate impact functions using observed data.")
    print("The calibration module uses Bayesian optimization to fit impact functions")
    print("to historical damage records, improving the accuracy of risk estimates.")
    
    print("\nExample calibration workflow (pseudocode):")
    print("""
    from climada.util.calibrate import ImpactCalibration
    
    # Prepare observed damage data
    obs_data = pd.DataFrame({
        'event_id': [1, 2, 3],
        'intensity': [50, 60, 70],  # e.g., wind speed
        'damage': [1e6, 5e6, 10e6]  # observed damages
    })
    
    # Create initial impact function
    impf_initial = ImpactFunc()
    # ... define initial parameters ...
    
    # Run calibration
    calib = ImpactCalibration(impf=impf_initial)
    impf_calibrated = calib.fit(
        hazard=hazard,
        exposure=exposure,
        observations=obs_data
    )
    
    # Compare original and calibrated functions
    # Use calibrated function for improved risk estimates
    """)
    
    print("\nFor more details, see:")
    print("  - CLIMADA calibration documentation")
    print("  - Research paper: doi.org/10.21105/joss.06755")


def visualize_impact_functions(impf_set):
    """
    Visualize all impact functions in a set.
    
    Args:
        impf_set: ImpactFuncSet containing impact functions
    """
    print("\nGenerating impact function visualizations...")
    
    # Get all hazard types
    haz_types = impf_set.get_hazard_types()
    n_types = len(haz_types)
    
    # Create subplots
    fig, axes = plt.subplots(1, n_types, figsize=(6*n_types, 5))
    if n_types == 1:
        axes = [axes]
    
    for idx, haz_type in enumerate(haz_types):
        ax = axes[idx]
        
        # Get impact function(s) for this hazard type
        impf_list = impf_set.get_func(haz_type=haz_type)
        
        for impf in impf_list:
            # Plot MDD and PAA
            ax.plot(impf.intensity, impf.mdd, 'o-', 
                    label=f'MDD - {impf.name}', linewidth=2, markersize=6)
            ax.plot(impf.intensity, impf.paa, 's--', 
                    label=f'PAA - {impf.name}', linewidth=2, markersize=6, alpha=0.7)
            
            ax.set_xlabel(f'Intensity ({impf.intensity_unit})', fontsize=11)
            ax.set_ylabel('Damage Ratio / Affected Fraction', fontsize=11)
            ax.set_title(f'{haz_type} Impact Function\n{impf.name}', fontsize=12, fontweight='bold')
            ax.grid(True, alpha=0.3)
            ax.legend(loc='upper left', fontsize=9)
            ax.set_ylim(-0.05, 1.05)
            
            # Add explanation text
            explanation = "MDD: Mean Damage Degree (fraction of value lost)\n"
            explanation += "PAA: Percentage of Affected Assets"
            ax.text(0.98, 0.05, explanation,
                    transform=ax.transAxes,
                    verticalalignment='bottom',
                    horizontalalignment='right',
                    fontsize=8,
                    bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))
    
    plt.tight_layout()
    
    # Save figure
    output_dir = Path(__file__).parent.parent / 'data' / 'vulnerability'
    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / 'impact_functions.png'
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    print(f"  Saved visualization to: {output_path}")
    
    plt.close()


def main():
    """Main workflow execution."""
    print("=" * 60)
    print("CLIMADA Vulnerability (Impact) Functions")
    print("=" * 60)
    
    try:
        # Create individual impact functions
        print("\n### Creating Impact Functions ###")
        tc_impf = create_tropical_cyclone_impact_function()
        
        # Create a complete set
        print("\n### Creating Impact Function Set ###")
        impf_set = create_impact_function_set()
        
        # Visualize
        visualize_impact_functions(impf_set)
        
        # Calibration concept
        demonstrate_calibration_concept()
        
        print("\n" + "=" * 60)
        print("Vulnerability functions workflow completed!")
        print("=" * 60)
        print("\nKey Concepts:")
        print("  - Impact Functions define damage vs. intensity relationships")
        print("  - MDD (Mean Damage Degree): fraction of asset value lost")
        print("  - PAA (Percentage Affected Assets): fraction of exposed assets affected")
        print("  - Calibration improves accuracy using observed damage data")
        
        print("\nNext Steps:")
        print("1. Define impact functions appropriate for your assets and hazards")
        print("2. Consider calibrating with historical damage data if available")
        print("3. Combine with exposure and hazard data for risk calculation")
        print("4. Validate results against known events")
        
        print("\nBuilt-in Impact Functions:")
        print("  - CLIMADA includes default functions for many hazard types")
        print("  - Use ImpactFuncSet methods to load standard functions")
        print("  - Example: impf_set.from_tc_default() for tropical cyclones")
        
    except Exception as e:
        print(f"\nError during workflow execution: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
